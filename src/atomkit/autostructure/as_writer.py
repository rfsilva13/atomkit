"""
AUTOSTRUCTURE input file writer.

This module provides the ASWriter class for generating AUTOSTRUCTURE .dat files
with a Pythonic interface.
"""

from __future__ import annotations
from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any, Mapping, Sequence

# Import atomkit utilities
if TYPE_CHECKING:
    from atomkit import Configuration
    from atomkit.shell import Shell

# Runtime imports
try:
    from atomkit import Configuration
    from atomkit.shell import Shell
    from atomkit.definitions import L_QUANTUM_MAP
except ImportError:
    # Fallback for development/testing
    Configuration = None  # type: ignore
    Shell = None  # type: ignore
    L_QUANTUM_MAP = {}  # type: ignore


class ASWriter:
    """
    Generate AUTOSTRUCTURE input files (.dat format) with a Pythonic interface.

    AUTOSTRUCTURE uses NAMELIST-based input (Fortran style) with free-format
    configuration specifications. This class automates the generation of
    properly formatted input files.

    Key Differences from FAC
    ------------------------
    - Non-relativistic by default (though relativistic modes exist)
    - NAMELIST format: &NAME VAR=value &END
    - Configurations specified as orbital occupation numbers
    - More explicit coupling scheme specification (LS, IC, CA)

    Parameters
    ----------
    filename : str
        Output .dat filename

    Examples
    --------
    Basic structure calculation:

    >>> from atomkit.autostructure import ASWriter
    >>> from atomkit import Configuration
    >>>
    >>> ground = Configuration.from_string("1s2.2s2.2p6")
    >>> excited = ground.generate_excitations(["3s", "3p"], excitation_level=1)
    >>>
    >>> with ASWriter("ne_structure.dat") as asw:
    ...     asw.write_header("Ne-like structure")
    ...     asw.add_salgeb(CUP='LS', RAD='E1', MXCONF=1+len(excited))
    ...     asw.configs_from_atomkit([ground] + excited, last_core_orbital='1s')
    ...     asw.add_sminim(NZION=10)
    """

    def __init__(self, filename: str):
        """
        Initialize AUTOSTRUCTURE writer.

        Parameters
        ----------
        filename : str
            Output filename (typically .dat extension)
        """
        self.filename = Path(filename)
        self.lines: list[str] = []
        self.orbitals: list[tuple[int, int]] = []  # (n, l) pairs
        self.configurations: list[list[int]] = []  # occupation numbers
        self._file_handle = None

    def __enter__(self) -> ASWriter:
        """Context manager entry."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - writes file automatically."""
        if exc_type is None:
            self.close()
        return False

    def write_header(self, comment: str = "") -> None:
        """
        Write mandatory A.S. header line.

        The first 4 characters MUST be 'A.S.' for AUTOSTRUCTURE to recognize
        the file format. The rest of the line is for comments.

        Parameters
        ----------
        comment : str, optional
            Descriptive comment for this calculation

        Notes
        -----
        This must be called first before any other methods.
        """
        if self.lines:
            raise ValueError("Header must be written first!")
        self.lines.append(f"A.S. {comment}")
        self.add_comment(
            f"Generated by atomkit on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )

    def add_comment(self, text: str) -> None:
        """
        Add a comment line.

        Parameters
        ----------
        text : str
            Comment text (# will be prepended automatically)
        """
        self.lines.append(f"# {text}")

    def add_blank_line(self) -> None:
        """Add a blank line for readability."""
        self.lines.append("")

    def add_salgeb(
        self,
        MXCONF: int | None = None,
        MXVORB: int | None = None,
        MXCCF: int = 0,
        CUP: str = "LS",
        RAD: str = "  ",
        RUN: str = "  ",
        **kwargs,
    ) -> None:
        """
        Add SALGEB namelist (algebra and configuration specification).

        Parameters
        ----------
        MXCONF : int, optional
            Number of N-electron configurations (will be auto-set if using
            configs_from_atomkit)
        MXVORB : int, optional
            Number of distinct valence orbitals (will be auto-set if using
            configs_from_atomkit)
        MXCCF : int, optional
            Number of (N+1)-electron bound configurations for autoionization.
            Default is 0 (no autoionization)
        CUP : str, optional
            Coupling scheme:
            - 'LS': LS-coupling (default, non-relativistic)
            - 'IC': Intermediate coupling (non-relativistic with fine structure)
            - 'CA': Configuration average
            - 'LSM'/'MVD': LS with mass-velocity and Darwin
            - 'ICM': IC with mass-velocity and Darwin
            - 'ICR': Kappa-averaged relativistic (IC)
        RAD : str, optional
            Radiation type:
            - '  ' or 'NO': No radiation (default)
            - 'E1' or 'YES': Electric dipole
            - 'E2' or 'M1': Add quadrupole and magnetic dipole
            - 'E3' or 'M2': Add octupole and magnetic quadrupole
            - 'ALL': All available radiation
        RUN : str, optional
            Calculation type:
            - '  ': Structure only (default)
            - 'PI': Photoionization
            - 'DR': Dielectronic recombination
            - 'RR': Radiative recombination
            - 'PE': Photoexcitation-autoionization
            - 'RE': Resonant excitation
            - 'DE': Direct electron impact excitation
        **kwargs : dict
            Additional SALGEB parameters (see AS manual)
            Common options:
            - KCOR1, KCOR2: Closed shell specification
            - NAST, NASTJ: Restrict term/level symmetries
            - KCUT: Correlation configuration handling

        Notes
        -----
        If using configs_from_atomkit(), MXCONF and MXVORB will be set
        automatically and don't need to be specified here.

        Examples
        --------
        >>> asw.add_salgeb(CUP='IC', RAD='E1')
        >>> asw.add_salgeb(CUP='LS', RAD='E1', KCOR1=1, KCOR2=1)  # 1s core
        """
        params: dict[str, int | str | float] = {
            "CUP": self._quote_value(CUP),
            "RAD": self._quote_value(RAD),
        }

        if RUN.strip():
            params["RUN"] = self._quote_value(RUN)

        if MXCONF is not None:
            params["MXCONF"] = MXCONF
        if MXVORB is not None:
            params["MXVORB"] = MXVORB
        if MXCCF != 0:
            params["MXCCF"] = MXCCF

        # Add any additional parameters
        for key, value in kwargs.items():
            if isinstance(value, str):
                params[key] = self._quote_value(value)
            else:
                params[key] = value

        self._write_namelist("SALGEB", params)

    def add_orbitals(self, orbitals: list[tuple[int, int]]) -> None:
        """
        Manually add orbital definitions (n, l pairs).

        Parameters
        ----------
        orbitals : list of (n, l) tuples
            Orbital quantum numbers
            Example: [(1, 0), (2, 0), (2, 1)] for 1s, 2s, 2p

        Notes
        -----
        Typically you should use configs_from_atomkit() which handles this
        automatically. This method is for advanced/manual usage.
        """
        self.orbitals = orbitals
        # Write orbital definitions: n1 l1  n2 l2  n3 l3 ...
        nl_line = "  ".join(f"{n} {l}" for n, l in orbitals)
        self.lines.append(nl_line)

    def add_configurations(self, configs: list[list[int]]) -> None:
        """
        Manually add configuration occupation numbers.

        Parameters
        ----------
        configs : list of lists
            Each inner list contains occupation numbers for the orbitals
            Example: [[2, 2, 0], [2, 1, 1], [2, 0, 2]] for 1s2.2s2, 1s2.2s1.2p1, 1s2.2p2

        Notes
        -----
        Typically you should use configs_from_atomkit() which handles this
        automatically. This method is for advanced/manual usage.
        """
        self.configurations = configs
        for occ_numbers in configs:
            occ_line = "  ".join(f"{occ:2d}" for occ in occ_numbers)
            self.lines.append(occ_line)

    def configs_from_atomkit(
        self,
        configurations: list[Any],  # list[Configuration]
        last_core_orbital: str | None = None,
        auto_detect_core: bool = True,
        optimize_from_orbital: str | None = None,
    ) -> dict:
        """
        Convert atomkit Configuration objects to AUTOSTRUCTURE format.

        This is the primary method for adding configurations - it automatically
        handles the conversion from Configuration objects to AS occupation numbers.

        Parameters
        ----------
        configurations : list of Configuration
            List of atomkit Configuration objects
        last_core_orbital : str, optional
            Last orbital in the closed core (e.g., '1s', '2p', '3p').
            If specified, core orbitals up to and including this one will be
            treated as closed shells via KCOR1/KCOR2.
            NOTE: If optimize_from_orbital is set, it overrides this for lambda optimization.
        auto_detect_core : bool, optional
            If True, automatically detect common core orbitals across all
            configurations. Default is True.
        optimize_from_orbital : str, optional
            If lambda optimization is planned, specify the first orbital to optimize from
            (e.g., '2s'). All orbitals from this one onwards will be written explicitly
            (not in core) so lambda parameters can act on them. Orbitals before this
            will be treated as core. This automatically handles the requirement that
            lambda parameters only act on explicitly listed orbitals.

        Returns
        -------
        dict
            Information about the conversion including:
            - 'n_orbitals': Number of distinct orbitals
            - 'n_configs': Number of configurations
            - 'core_orbitals': List of core orbital labels
            - 'valence_orbitals': List of valence orbital labels

        Examples
        --------
        >>> # Normal calculation with core
        >>> ground = Configuration.from_string("1s2.2s2.2p6")
        >>> excited = ground.generate_excitations(["3s", "3p"], 1)
        >>> asw.configs_from_atomkit([ground] + excited, last_core_orbital='1s')

        >>> # Lambda optimization starting from 2s
        >>> asw.configs_from_atomkit([ground] + excited, optimize_from_orbital='2s')
        >>> # This will write: 2s, 2p, 3s, 3p (all explicit) and put 1s in core

        Notes
        -----
        This method will update MXCONF and MXVORB automatically, so you don't
        need to specify them in add_salgeb() if you call this first.

        For lambda optimization, use optimize_from_orbital instead of last_core_orbital
        to ensure orbitals you want to optimize are explicitly written.
        """
        if not configurations:
            raise ValueError("Must provide at least one configuration")

        # Collect all unique orbitals across all configurations
        all_orbitals = set()
        for config in configurations:
            for shell in config.shells:
                all_orbitals.add((shell.n, shell.l_quantum))

        # Sort orbitals by (n, l)
        sorted_orbitals = sorted(all_orbitals)
        self.orbitals = sorted_orbitals

        # Detect core if requested
        core_orbitals = []

        # Priority: optimize_from_orbital > last_core_orbital > auto_detect
        if optimize_from_orbital:
            # Lambda optimization mode: orbitals BEFORE optimize_from_orbital go to core
            # Orbitals FROM optimize_from_orbital onwards are written explicitly
            if Shell is None:
                raise ImportError(
                    "Shell class not available - cannot parse optimize_from_orbital"
                )
            opt_shell = Shell.from_string(optimize_from_orbital + "1")
            opt_n, opt_l = opt_shell.n, opt_shell.l_quantum

            # Core = orbitals BEFORE the optimization starting point
            core_orbitals = [
                (n, l) for n, l in sorted_orbitals if (n, l) < (opt_n, opt_l)
            ]

        elif auto_detect_core or last_core_orbital:
            if last_core_orbital:
                # User specified core - use Shell class
                if Shell is None:
                    raise ImportError(
                        "Shell class not available - cannot parse core orbital"
                    )
                core_shell = Shell.from_string(
                    last_core_orbital + "1"
                )  # Add dummy occupation
                core_n, core_l = core_shell.n, core_shell.l_quantum
                core_orbitals = [
                    (n, l) for n, l in sorted_orbitals if (n, l) <= (core_n, core_l)
                ]
            else:
                # Auto-detect: find orbitals with same occupation in all configs
                orbital_occs = {orb: [] for orb in sorted_orbitals}
                for config in configurations:
                    for orb in sorted_orbitals:
                        n, l = orb
                        occ = sum(
                            shell.occupation
                            for shell in config.shells
                            if shell.n == n and shell.l_quantum == l
                        )
                        orbital_occs[orb].append(occ)

                # Core orbitals have constant, non-zero occupation
                for orb, occs in orbital_occs.items():
                    if len(set(occs)) == 1 and occs[0] > 0:
                        core_orbitals.append(orb)

        # Valence orbitals are non-core orbitals
        valence_orbitals = [orb for orb in sorted_orbitals if orb not in core_orbitals]

        # Write orbital definitions (valence only if core is separated)
        orbitals_to_write = valence_orbitals if core_orbitals else sorted_orbitals
        nl_line = "  ".join(f"{n} {l}" for n, l in orbitals_to_write)
        self.lines.append(nl_line)

        # Convert each configuration to occupation numbers
        config_occs = []
        for config in configurations:
            occ_numbers = []
            for n, l in orbitals_to_write:
                occ = sum(
                    shell.occupation
                    for shell in config.shells
                    if shell.n == n and shell.l_quantum == l
                )
                occ_numbers.append(occ)
            config_occs.append(occ_numbers)

        # Write configuration occupation numbers
        for occ_numbers in config_occs:
            occ_line = "  ".join(f"{occ:2d}" for occ in occ_numbers)
            self.lines.append(occ_line)

        self.configurations = config_occs

        # Update SALGEB parameters in the most recent namelist if it exists
        # Remove any existing MXCONF/MXVORB and add new values
        for i in range(len(self.lines) - 1, -1, -1):
            if "&SALGEB" in self.lines[i]:
                # Remove existing MX parameters if present
                import re

                line = self.lines[i]
                line = re.sub(r"\s*MXCONF=\d+", "", line)
                line = re.sub(r"\s*MXVORB=\d+", "", line)
                # Add new values before &END
                line = line.replace("&END", "")
                line += f" MXCONF={len(configurations)} MXVORB={len(orbitals_to_write)} &END"
                self.lines[i] = line
                break

        return {
            "n_orbitals": len(orbitals_to_write),
            "n_configs": len(configurations),
            "core_orbitals": [self._orbital_label(n, l) for n, l in core_orbitals],
            "valence_orbitals": [
                self._orbital_label(n, l) for n, l in valence_orbitals
            ],
        }

    def add_sminim(
        self, NZION: int, INCLUD: int = 0, NLAM: int = 0, NVAR: int = 0, **kwargs
    ) -> None:
        """
        Add SMINIM namelist (radial potential and minimization).

        Parameters
        ----------
        NZION : int
            Nuclear charge (atomic number)
            > 0: Thomas-Fermi-Dirac-Amaldi potential (non-relativistic)
            < 0: Hartree potential with Slater-Type-Orbitals
        INCLUD : int, optional
            Variational minimization:
            = 0: No minimization (default)
            > 0: Include lowest INCLUD terms in energy functional
            < 0: Read specific terms and weights
        NLAM : int, optional
            Number of scaling parameters (lambdas) for optimization.
            Default is 0 (all lambdas = 1.0)
        NVAR : int, optional
            Number of variational parameters to optimize.
            Default is 0 (no optimization)
        **kwargs : dict
            Additional SMINIM parameters:
            - PRINT: 'FORM' (default, detailed) or 'UNFORM' (compact)
            - MAXE: Maximum scattering energy (Rydbergs)
            - ORTHOG: 'YES'/'NO' for Schmidt orthogonalization
            - IREL: Relativistic mode (for CUP='ICR')
            - INUKE: Nuclear model (for relativistic calculations)
            - QED: QED corrections (0=off, 1=on)

        Examples
        --------
        >>> asw.add_sminim(NZION=6)  # Carbon
        >>> asw.add_sminim(NZION=26, INCLUD=6, NLAM=3, NVAR=2)  # Optimized Fe
        """
        params: dict[str, int | str | float] = {"NZION": NZION}

        if INCLUD != 0:
            params["INCLUD"] = INCLUD
        if NLAM != 0:
            params["NLAM"] = NLAM
        if NVAR != 0:
            params["NVAR"] = NVAR

        # Add any additional parameters
        for key, value in kwargs.items():
            if isinstance(value, str):
                params[key] = self._quote_value(value)
            else:
                params[key] = value

        self._write_namelist("SMINIM", params)

    def add_sradcon(
        self,
        MENG: int = 0,
        EMIN: float | None = None,
        EMAX: float | None = None,
        **kwargs,
    ) -> None:
        """
        Add SRADCON namelist (continuum energy grid for autoionization/photoionization).

        Only needed for calculations with continuum electrons (autoionization,
        photoionization, recombination, etc.)

        Parameters
        ----------
        MENG : int, optional
            Number of interpolation energies:
            = 0: Auto-select (default)
            > 0: Read MENG energies after namelist
            < 0: Generate -MENG energies between EMIN and EMAX
        EMIN : float, optional
            Minimum continuum energy (Rydbergs)
        EMAX : float, optional
            Maximum continuum energy (Rydbergs)
        **kwargs : dict
            Additional SRADCON parameters:
            - ECORLS/ECORIC: Energy correction for target continuum
            - NDE: Number of excitation energies

        Examples
        --------
        >>> asw.add_sradcon(MENG=-15, EMIN=0.0, EMAX=25.0)
        >>> asw.add_sradcon()  # Auto-select energies
        """
        params = {}

        if MENG != 0:
            params["MENG"] = MENG
        if EMIN is not None:
            params["EMIN"] = EMIN
        if EMAX is not None:
            params["EMAX"] = EMAX

        # Add any additional parameters
        for key, value in kwargs.items():
            if isinstance(value, str):
                params[key] = self._quote_value(value)
            else:
                params[key] = value

        self._write_namelist("SRADCON", params)

    def add_drr(
        self,
        NMIN: int,
        NMAX: int,
        LMIN: int = 0,
        LMAX: int = 7,
        NMESH: int | None = None,
        **kwargs,
    ) -> None:
        """
        Add DRR namelist (Rydberg series for DR/RR calculations).

        Only needed when RUN='DR', 'RR', 'PE', or 'RE' in SALGEB.

        Parameters
        ----------
        NMIN : int
            Minimum principal quantum number for Rydberg series
        NMAX : int
            Maximum principal quantum number for Rydberg series
        LMIN : int, optional
            Minimum angular momentum. Default is 0.
        LMAX : int, optional
            Maximum angular momentum. Default is 7.
        NMESH : int, optional
            Number of additional n-values for interpolation:
            = 0: None
            > 0: Read NMESH values after namelist
            < 0: Use internal n-mesh (RECOMMENDED for production)
            = None: Don't specify (use AS default)
        **kwargs : dict
            Additional DRR parameters:
            - NRAD: n-value above which no new radiative rates are calculated
            - LCON: Number of continuum l-values

        Examples
        --------
        >>> asw.add_drr(NMIN=3, NMAX=15, LMIN=0, LMAX=7)
        >>> asw.add_drr(NMIN=3, NMAX=10, LMIN=0, LMAX=5, NMESH=-1)
        """
        params: dict[str, int | str | float] = {
            "NMIN": NMIN,
            "NMAX": NMAX,
            "LMIN": LMIN,
            "LMAX": LMAX,
        }

        if NMESH is not None:
            params["NMESH"] = NMESH

        # Add any additional parameters
        for key, value in kwargs.items():
            if isinstance(value, str):
                params[key] = self._quote_value(value)
            else:
                params[key] = value

        self._write_namelist("DRR", params)

    def get_content(self) -> str:
        """
        Get the generated AUTOSTRUCTURE input as a string.

        Returns
        -------
        str
            Complete file content

        Examples
        --------
        >>> content = asw.get_content()
        >>> print(content)
        """
        return "\n".join(self.lines)

    def close(self) -> None:
        """
        Write the file to disk.

        This is called automatically when using the context manager.
        """
        content = self.get_content()
        self.filename.parent.mkdir(parents=True, exist_ok=True)
        with open(self.filename, "w") as f:
            f.write(content)
            f.write("\n")  # Ensure file ends with newline

    # Helper methods

    def _write_namelist(
        self, name: str, params: Mapping[str, int | str | float]
    ) -> None:
        """Write a NAMELIST block."""
        param_str = " ".join(f"{key}={value}" for key, value in params.items())
        self.lines.append(f" &{name} {param_str} &END")

    def _quote_value(self, value: str) -> str:
        """Add quotes to string values for NAMELIST."""
        if not value:
            return "'  '"
        if not value.startswith("'"):
            return f"'{value}'"
        return value

    def _orbital_label(self, n: int, l: int) -> str:
        """Convert (n, l) to spectroscopic notation using atomkit's definitions."""
        # Use atomkit's L_QUANTUM_MAP for consistency
        if l in L_QUANTUM_MAP:
            l_symbol = L_QUANTUM_MAP[l]
        else:
            # Handle high l values
            l_symbol = f"[l={l}]"
        return f"{n}{l_symbol}"
