"""
SFAC Writer - Python wrapper for generating FAC input files.

This module provides a Python class that generates SFAC (Simple FAC) format
input files (.sf extension) that can be executed by FAC command-line tools.

The SFACWriter class acts as a context manager and provides methods corresponding
to all major FAC functions documented in the FAC manual.
"""

from pathlib import Path
from typing import Union, List, Optional, Any
from io import StringIO


class SFACWriter:
    """
    A Python wrapper for generating FAC SFAC input files.

    This class provides a Pythonic interface to create SFAC format files that
    can be executed by the FAC command-line tools (sfac, scrm, spol).

    Instead of requiring pfac Python bindings, this approach generates text
    input files in SFAC format, allowing you to:
    - Use modern Python syntax and capabilities
    - Generate FAC inputs programmatically from atomkit configurations
    - Avoid dependency on pfac compilation
    - Have full control over the input generation

    The class can be used as a context manager to ensure proper file handling:

    Example:
        >>> with SFACWriter("calculation.sf") as fac:
        ...     fac.SetAtom("Fe")
        ...     fac.Closed("1s")
        ...     fac.Config("2*8", group="n2")
        ...     fac.Structure("output.lev.b", ["n2"])

    Or used directly:
        >>> fac = SFACWriter("calculation.sf")
        >>> fac.SetAtom("Fe")
        >>> fac.Closed("1s")
        >>> fac.close()

    Attributes:
        filename: Path to the output .sf file
        _file: File handle for writing
        _commands: List of SFAC commands to write
        _in_context: Whether being used as context manager
    """

    def __init__(self, filename: Union[str, Path], auto_write: bool = False):
        """
        Initialize the SFAC writer.

        Args:
            filename: Path where the .sf file will be written
            auto_write: If True, write commands immediately. If False,
                       accumulate commands and write on close/exit.
        """
        self.filename = Path(filename)
        self._commands: List[str] = []
        self._file = None
        self._in_context = False
        self._auto_write = auto_write

        if auto_write:
            self._file = open(self.filename, "w")
            self._write_header()

    def __enter__(self):
        """Enter context manager."""
        self._in_context = True
        if not self._auto_write:
            self._file = open(self.filename, "w")
            self._write_header()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit context manager and write accumulated commands."""
        self.close()
        return False

    def _write_header(self):
        """Write file header with timestamp and description."""
        from datetime import datetime

        header = f"""# FAC SFAC Input File
# Generated by atomkit on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# This file can be executed with: sfac {self.filename.name}

"""
        if self._auto_write:
            self._file.write(header)
        else:
            self._commands.insert(0, header)

    def _format_value(self, value: Any) -> str:
        """
        Format a Python value for SFAC syntax.

        Args:
            value: Python value to format

        Returns:
            String representation suitable for SFAC
        """
        if isinstance(value, str):
            # Check if already quoted
            if value.startswith(("'", '"')) and value.endswith(("'", '"')):
                return value
            return f"'{value}'"
        elif isinstance(value, (list, tuple)):
            # Format as SFAC list
            formatted = [self._format_value(v) for v in value]
            return f"[{', '.join(formatted)}]"
        elif isinstance(value, bool):
            # Python bool to SFAC (0/1 or True/False)
            return str(int(value))
        elif value is None:
            return "None"
        else:
            return str(value)

    def _write_command(self, func_name: str, *args, **kwargs):
        """
        Write a FAC function call to the output file.

        Args:
            func_name: Name of the FAC function
            *args: Positional arguments
            **kwargs: Keyword arguments
        """
        # Format arguments
        formatted_args = [self._format_value(arg) for arg in args]

        # Format keyword arguments
        formatted_kwargs = [
            f"{key} = {self._format_value(value)}" for key, value in kwargs.items()
        ]

        # Combine all arguments
        all_args = formatted_args + formatted_kwargs
        args_str = ", ".join(all_args)

        # Create the command line
        command = f"{func_name}({args_str})\n"

        if self._auto_write:
            self._file.write(command)
            self._file.flush()
        else:
            self._commands.append(command)

    def add_comment(self, comment: str):
        """
        Add a comment to the SFAC file.

        Args:
            comment: Comment text (# will be added automatically)
        """
        lines = comment.strip().split("\n")
        for line in lines:
            comment_line = f"# {line}\n"
            if self._auto_write:
                self._file.write(comment_line)
            else:
                self._commands.append(comment_line)

    def add_blank_line(self):
        """Add a blank line for readability."""
        if self._auto_write:
            self._file.write("\n")
        else:
            self._commands.append("\n")

    def close(self):
        """Close the file and write all accumulated commands."""
        if self._file is None:
            return

        if not self._auto_write:
            # Write all accumulated commands
            for command in self._commands:
                self._file.write(command)

        self._file.close()
        self._file = None

    # ==========================================================================
    # ATOMIC STRUCTURE CALCULATIONS
    # ==========================================================================

    def SetAtom(self, symbol: str):
        """
        Set the atomic element for the calculation.

        Args:
            symbol: Chemical symbol (e.g., 'Fe', 'Cu', 'O')

        Example:
            >>> fac.SetAtom('Fe')
        """
        self._write_command("SetAtom", symbol)

    def Closed(self, shells: str):
        """
        Specify closed (inactive) shells.

        The closed shells will not be included in the active space of the
        calculation. Multiple shells can be specified separated by spaces.

        Args:
            shells: Space-separated shell notation (e.g., '1s', '1s 2s 2p')

        Example:
            >>> fac.Closed('1s')
            >>> fac.Closed('1s 2s 2p')
        """
        self._write_command("Closed", shells)

    def Config(self, config: str, group: Optional[str] = None, **kwargs):
        """
        Define an electronic configuration or configuration group.

        Configurations can be specified in several formats:
        - Shell notation: '1s2 2s2 2p6 3s1'
        - Complex notation: '2*8' (n=2 complex with 8 electrons)
        - Excitation notation: '2*7 3*1' (one electron from n=2 to n=3)

        Args:
            config: Configuration string
            group: Optional group name/label for this configuration
            **kwargs: Additional parameters passed to Config

        Example:
            >>> fac.Config('2*8', group='n2')
            >>> fac.Config('2*7 3*1', group='n3')
            >>> fac.Config('1s2 2s2 2p5 3s1', group='excited')
        """
        if group is not None:
            kwargs["group"] = group
        self._write_command("Config", config, **kwargs)

    def ConfigEnergy(self, mode: int):
        """
        Calculate configuration energies for optimization.

        This is typically called twice in a calculation:
        - ConfigEnergy(0): Calculate with individually optimized potentials
        - ConfigEnergy(1): Recalculate with global potential

        The difference provides a correction for the optimization procedure.

        Args:
            mode: 0 for individual optimization, 1 for global potential

        Example:
            >>> fac.ConfigEnergy(0)
            >>> fac.OptimizeRadial(['n2'])
            >>> fac.ConfigEnergy(1)
        """
        self._write_command("ConfigEnergy", mode)

    def OptimizeRadial(self, groups: List[str], **kwargs):
        """
        Optimize the radial potential for specified configuration groups.

        This performs a self-consistent Dirac-Fock-Slater calculation to
        determine the optimal central potential. Only pass the lowest-lying
        configurations (typically ground or low-lying excited states).

        Args:
            groups: List of configuration group names to optimize
            **kwargs: Additional optimization parameters

        Example:
            >>> fac.OptimizeRadial(['n2'])
            >>> fac.OptimizeRadial(['ground', 'n2'], maxiter=100)
        """
        self._write_command("OptimizeRadial", groups, **kwargs)

    def Structure(self, output_file: str, groups: List[str], **kwargs):
        """
        Calculate energy levels and save to binary file.

        This sets up the Hamiltonian matrix, diagonalizes it, and saves
        the resulting energy levels to a binary file.

        Args:
            output_file: Output filename (typically .lev.b extension)
            groups: List of configuration groups to include
            **kwargs: Additional parameters

        Example:
            >>> fac.Structure('ne.lev.b', ['n2', 'n3'])
        """
        self._write_command("Structure", output_file, groups, **kwargs)

    def MemENTable(self, filename: str):
        """
        Load energy level table into memory.

        This is required before converting binary files to verbose ASCII format.
        Not needed for simple ASCII conversion.

        Args:
            filename: Binary energy level file to load

        Example:
            >>> fac.MemENTable('ne.lev.b')
            >>> fac.PrintTable('ne.lev.b', 'ne.lev', 1)
        """
        self._write_command("MemENTable", filename)

    def PrintTable(self, input_file: str, output_file: str, verbose: int = 1):
        """
        Convert binary output file to ASCII format.

        Args:
            input_file: Input binary file
            output_file: Output ASCII file
            verbose: 0 for simple format, 1 for verbose format

        Example:
            >>> fac.PrintTable('ne.lev.b', 'ne.lev', 1)
            >>> fac.PrintTable('ne.tr.b', 'ne.tr', 0)
        """
        self._write_command("PrintTable", input_file, output_file, verbose)

    # ==========================================================================
    # RADIATIVE TRANSITIONS
    # ==========================================================================

    def TransitionTable(
        self,
        output_file: str,
        lower_groups: List[str],
        upper_groups: List[str],
        multipole: int = 0,
        **kwargs,
    ):
        """
        Calculate radiative transition rates.

        Computes oscillator strengths and transition rates between configuration
        groups.

        Args:
            output_file: Output filename (typically .tr.b extension)
            lower_groups: List of lower level configuration groups
            upper_groups: List of upper level configuration groups
            multipole: Multipole type (0=all, -1=E1, +1=M1, -2=E2, etc.)
            **kwargs: Additional parameters (gauge, mode, etc.)

        Example:
            >>> fac.TransitionTable('ne.tr.b', ['n2'], ['n3'])
            >>> fac.TransitionTable('ne.tr.b', ['n2'], ['n3'], multipole=-1)
        """
        args = [output_file, lower_groups, upper_groups]
        if multipole != 0:
            args.append(multipole)
        self._write_command("TransitionTable", *args, **kwargs)

    # Alias for compatibility
    def TRTable(
        self,
        output_file: str,
        lower_groups: List[str],
        upper_groups: List[str],
        multipole: int = 0,
        **kwargs,
    ):
        """Alias for TransitionTable."""
        self.TransitionTable(
            output_file, lower_groups, upper_groups, multipole, **kwargs
        )

    # ==========================================================================
    # COLLISIONAL PROCESSES
    # ==========================================================================

    def CETable(
        self,
        output_file: str,
        lower_groups: List[str],
        upper_groups: List[str],
        **kwargs,
    ):
        """
        Calculate electron impact excitation cross sections.

        Args:
            output_file: Output filename (typically .ce.b extension)
            lower_groups: List of lower level configuration groups
            upper_groups: List of upper level configuration groups
            **kwargs: Additional parameters (energy grid, etc.)

        Example:
            >>> fac.CETable('ne.ce.b', ['n2'], ['n3'])
        """
        self._write_command(
            "CETable", output_file, lower_groups, upper_groups, **kwargs
        )

    def CITable(
        self,
        output_file: str,
        bound_groups: List[str],
        free_groups: List[str],
        **kwargs,
    ):
        """
        Calculate electron impact ionization cross sections.

        Args:
            output_file: Output filename (typically .ci.b extension)
            bound_groups: List of bound state configuration groups
            free_groups: List of continuum configuration groups
            **kwargs: Additional parameters

        Example:
            >>> fac.CITable('fe.ci.b', ['n2'], ['continuum'])
        """
        self._write_command("CITable", output_file, bound_groups, free_groups, **kwargs)

    # ==========================================================================
    # PHOTOIONIZATION AND RECOMBINATION
    # ==========================================================================

    def RRTable(
        self,
        output_file: str,
        bound_groups: List[str],
        free_groups: List[str],
        **kwargs,
    ):
        """
        Calculate radiative recombination and photoionization cross sections.

        Args:
            output_file: Output filename (typically .rr.b extension)
            bound_groups: List of bound state configuration groups
            free_groups: List of continuum configuration groups
            **kwargs: Additional parameters

        Example:
            >>> fac.RRTable('fe.rr.b', ['n2'], ['continuum'])
        """
        self._write_command("RRTable", output_file, bound_groups, free_groups, **kwargs)

    # ==========================================================================
    # AUTOIONIZATION
    # ==========================================================================

    def AITable(
        self,
        output_file: str,
        bound_groups: List[str],
        free_groups: List[str],
        **kwargs,
    ):
        """
        Calculate autoionization rates.

        Computes autoionization rates from doubly-excited bound states to
        continuum states.

        Args:
            output_file: Output filename (typically .ai.b extension)
            bound_groups: List of bound state configuration groups
            free_groups: List of continuum configuration groups
            **kwargs: Additional parameters

        Example:
            >>> fac.AITable('fe_ai.ai.b', ['recombined'], ['target'])
        """
        self._write_command("AITable", output_file, bound_groups, free_groups, **kwargs)

    def AITableMSub(
        self,
        output_file: str,
        bound_groups: List[str],
        free_groups: List[str],
        **kwargs,
    ):
        """
        Calculate magnetic sublevel autoionization rates.

        Args:
            output_file: Output filename (typically .aim.b extension)
            bound_groups: List of bound state configuration groups
            free_groups: List of continuum configuration groups
            **kwargs: Additional parameters

        Example:
            >>> fac.AITableMSub('fe_ai.aim.b', ['recombined'], ['target'])
        """
        self._write_command(
            "AITableMSub", output_file, bound_groups, free_groups, **kwargs
        )

    # ==========================================================================
    # CALCULATION SETTINGS
    # ==========================================================================

    def SetBreit(self, mode: int):
        """
        Enable/disable Breit interaction.

        Args:
            mode: 0=off, -1=on (default approximation), >0=specific mode

        Example:
            >>> fac.SetBreit(-1)  # Enable Breit interaction
        """
        self._write_command("SetBreit", mode)

    def SetSE(self, mode: int):
        """
        Enable/disable self-energy corrections (QED).

        Args:
            mode: 0=off, -1=on (default approximation), >0=specific mode

        Example:
            >>> fac.SetSE(-1)  # Enable self-energy corrections
        """
        self._write_command("SetSE", mode)

    def SetVP(self, mode: int):
        """
        Enable/disable vacuum polarization corrections (QED).

        Args:
            mode: 0=off, -1=on (default approximation), >0=specific mode

        Example:
            >>> fac.SetVP(-1)  # Enable vacuum polarization
        """
        self._write_command("SetVP", mode)

    def SetMS(self, nms: int, sms: int):
        """
        Set mass and specific mass for nuclear recoil corrections.

        Args:
            nms: Nuclear mass number
            sms: Specific mass

        Example:
            >>> fac.SetMS(56, 0)  # For Fe-56
        """
        self._write_command("SetMS", nms, sms)

    def SetUTA(self, mode: int):
        """
        Enable/disable Unresolved Transition Array (UTA) mode.

        In UTA mode, transitions are treated as Gaussian arrays rather than
        individual lines.

        Args:
            mode: 0=off, 1=on

        Example:
            >>> fac.SetUTA(1)  # Enable UTA mode
        """
        self._write_command("SetUTA", mode)

    # ==========================================================================
    # ENERGY GRIDS
    # ==========================================================================

    def SetUsrCEGrid(self, grid: List[float], grid_type: int = 1):
        """
        Set user-defined energy grid for collisional excitation.

        Args:
            grid: List of energy values
            grid_type: 0=incident electron energy, 1=scattered electron energy

        Example:
            >>> fac.SetUsrCEGrid([0.1, 0.5, 1.0, 2.0, 5.0])
        """
        self._write_command("SetUsrCEGrid", grid, grid_type)

    def SetUsrCIGrid(self, grid: List[float], grid_type: int = 0):
        """
        Set user-defined energy grid for collisional ionization.

        Args:
            grid: List of energy values
            grid_type: 0=incident electron energy, 1=ejected electron energy

        Example:
            >>> fac.SetUsrCIGrid([0.1, 0.5, 1.0, 2.0, 5.0])
        """
        self._write_command("SetUsrCIGrid", grid, grid_type)

    def SetUsrPEGrid(self, grid: List[float], grid_type: int = 0):
        """
        Set user-defined energy grid for photoionization.

        Args:
            grid: List of energy values
            grid_type: 0=photon energy, 1=photoelectron energy

        Example:
            >>> fac.SetUsrPEGrid([0.1, 0.5, 1.0, 2.0, 5.0])
        """
        self._write_command("SetUsrPEGrid", grid, grid_type)

    # ==========================================================================
    # MPI AND PERFORMANCE
    # ==========================================================================

    def InitializeMPI(self, n_cores: int):
        """
        Initialize MPI for parallel calculation.

        Args:
            n_cores: Number of cores to use

        Example:
            >>> fac.InitializeMPI(24)
        """
        self._write_command("InitializeMPI", n_cores)

    def FinalizeMPI(self):
        """
        Finalize MPI and cleanup.

        Example:
            >>> fac.FinalizeMPI()
        """
        self._write_command("FinalizeMPI")

    def MPIRank(self, rank: Optional[int] = None):
        """
        Get or set MPI rank.

        Args:
            rank: MPI rank (optional)

        Example:
            >>> fac.MPIRank()
            >>> fac.MPIRank(0)
        """
        if rank is None:
            self._write_command("MPIRank")
        else:
            self._write_command("MPIRank", rank)

    # ==========================================================================
    # FILE CONVERSION
    # ==========================================================================

    def ConvertToSFAC(self, sfac_file: str):
        """
        Start writing to an SFAC output file.

        This is used when converting PFAC scripts to SFAC format.

        Args:
            sfac_file: Output .sf filename

        Example:
            >>> fac.ConvertToSFAC('calculation.sf')
        """
        self._write_command("ConvertToSFAC", sfac_file)

    def CloseSFAC(self):
        """
        Close the SFAC output file.

        Example:
            >>> fac.CloseSFAC()
        """
        self._write_command("CloseSFAC")

    # ==========================================================================
    # HELPER METHODS FOR ATOMKIT INTEGRATION
    # ==========================================================================

    def config_from_atomkit(self, config, group: str):
        """
        Add a configuration from an atomkit Configuration object.

        Args:
            config: atomkit Configuration object
            group: Group name for this configuration

        Example:
            >>> from atomkit import Configuration
            >>> ground = Configuration.from_element('Fe', 23)
            >>> fac.config_from_atomkit(ground, 'ground')
        """
        config_str = config.to_string(separator=" ")
        self.Config(config_str, group=group)

    def configs_from_atomkit(self, configs: List, group_prefix: str = "cfg"):
        """
        Add multiple configurations from atomkit Configuration objects.

        Args:
            configs: List of atomkit Configuration objects
            group_prefix: Prefix for auto-generated group names

        Example:
            >>> from atomkit import Configuration
            >>> ground = Configuration.from_element('Fe', 23)
            >>> excited = ground.generate_excitations(['3s', '3p'], 1)
            >>> fac.configs_from_atomkit([ground] + excited, 'level')
        """
        for i, config in enumerate(configs):
            group_name = f"{group_prefix}{i}"
            self.config_from_atomkit(config, group_name)

    def get_content(self) -> str:
        """
        Get the current SFAC file content as a string.

        Useful for debugging or previewing before writing to file.

        Returns:
            String containing all SFAC commands

        Example:
            >>> fac = SFACWriter("test.sf")
            >>> fac.SetAtom("Fe")
            >>> print(fac.get_content())
        """
        if self._auto_write:
            raise RuntimeError("Cannot get content in auto_write mode")
        return "".join(self._commands)
